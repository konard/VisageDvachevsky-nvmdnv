# Полный пайплайн работы в редакторе NovelMind

Цель: описать полный путь разработчика (от запуска редактора до play),
а также зафиксировать текущую архитектуру редактора и ее границы.
Документ описывает **реализованный** пайплайн и отдельный блок Next для
последующих улучшений.

## 0. Принципы

1. Один источник истины для контента. Визуальное редактирование и NMScript
   не должны расходиться.
2. WYSIWYG = максимально единый путь от данных до рендера (с оговорками ниже).
3. Каждое действие игрока в play должно быть воспроизводимо (детерминизм).
4. Никаких "пустых" запусков: при play всегда видим текущий узел/сцену.

## 1. Пайплайн разработчика (полный путь)

### 1.1 Старт и создание проекта
1) Запуск редактора -> Welcome.
2) Новый проект:
   - Шаблон (кинетик, с выбором, интерактивный).
   - Имя, путь, базовое разрешение, язык по умолчанию.
3) Генерация структуры:
   - `Assets/`, `Scenes/`, `Scripts/`, `Localization/`, `Build/`.
   - `project.json`, стартовый `main.nms`, пустая стартовая сцена.
4) Открытие проекта и автосохранение настроек окна.

### 1.2 Базовые настройки (перед контентом)
1) Project Settings:
   - Разрешение, безопасная зона, базовая шрифтовая тема, скорость текста.
2) Настройка путей:
   - Папки ассетов, локализация, экспортные профили.
3) Валидация:
   - Есть ли стартовая сцена? Есть ли entry-узел?

### 1.3 Импорт ассетов
1) Drag & drop в Asset Browser.
2) Для каждого файла:
   - Создается метадата (id, type, source path, imported path).
   - Миниатюры/формы волн добавляются при включенной генерации (если доступно).
3) Ошибки импорта:
   - Показываются в Diagnostics + предупреждение в UI.
4) Поведение при переименовании:
   - ID стабилен для уже импортированного пути. Переименование файла
     через проводник ОС считается новой сущностью (v2: умное сопоставление).

### 1.4 Story Graph (нарративный поток)
1) Создать Entry и подключить к стартовой сцене.
2) Добавить узлы:
   - Scene Node, Dialogue Node, Choice, Code, Jump, End.
3) У каждого узла:
   - Заголовок, краткое описание, ссылка на сцену/скрипт.
4) Визуальные связи:
   - Поддержка условных переходов и дефолтного пути.

### 1.5 "Войти" в узел и редактировать сцену
1) В Story Graph — двойной клик по Scene/Dialogue узлу.
2) Открывается Scene Editor для текущего `sceneId`.
3) Внутри сцены:
   - Фон, персонажи, UI, эффекты, z‑порядок, трансформы.
4) Сцена хранится в `.nmscene` как полный слой (дельты узлов — v2).

### 1.6 Работа с NMScript
1) Script Editor открывает `.nms` файлы напрямую.
2) Story Graph узлы привязаны к сценам и переходам; код правится отдельно.
3) Diagnostics панели показывают ошибки валидатора (если включен).

### 1.7 Preview / Play
1) Режимы:
   - Preview (статический рендер текущей сцены).
   - Play (полный runtime).
   - Step (пошагово: кадр/строка/инструкция).
2) Запуск:
   - Play from Entry.
   - Play from Node (текущий узел).
3) Во время play:
   - Scene View отображает runtime snapshot.
   - Dialogue/Choice overlay реагирует на вход.
   - Доступны save/load (слоты + авто-сейв).
4) Остановка:
   - Возврат в режим редактирования.
   - Очистка runtime объектов.

### 1.8 Итерации
1) Быстрое исправление сцены -> play from node.
2) Build/Export описаны в отдельном документе (в рамках этого этапа не исполняются).

## 2. Scene Graph (текущее состояние)

### 2.1 Главная идея
Сейчас редактор хранит сцену как единый слой, runtime использует snapshot.
Разделение ASG/RSG остается целевым улучшением (см. Next).

### 2.2 Authoring Scene Graph (ASG)
- Scene -> Objects (Sprite/Transform/FX) в `.nmscene`.
- Полный state сохранен в проекте.

### 2.3 Runtime Scene Graph (RSG)
- Создается при play (runtime host).
- Дает SceneSnapshot для UI/preview.

### 2.4 Дельты узлов (Scene Node Overrides)
Планируемая функция (Next). Сейчас сцена хранится целиком.

## 3. Play Mode (детально)

### 3.1 Состояния
Stopped -> Running -> Paused -> Stepping -> Stopped.
В каждом состоянии:
- Playing: runtime тик + snapshot
- Paused: только UI, без тика
- Stepping: tick по запросу

### 3.2 Контроль запуска
1) Проверка проекта (assets/scripts/scenes).
2) Компиляция NMScript в IR.
3) Создание Runtime Scene Graph.
4) Старт из Entry или выбранного узла.

### 3.3 Интеграция с редактором
- Scene View рендерит snapshot (RSG).
- Story Graph подсвечивает текущий узел.
- Inspector показывает runtime-only (read-only).

## 4. Preview (WYSIWYG)

### 4.1 Основная проблема
WYSIWYG ломается, если используются разные пути рендера.
Сейчас: editor использует QGraphicsView, runtime snapshot — GL превью.

### 4.2 Режимы превью
1) Edit Preview:
   - Рендер editor-сцены (QGraphicsView).
2) Play Preview:
   - Рендер runtime snapshot (GL viewport).

### 4.3 Экспорт snapshot
Snapshot содержит:
- background, visibleCharacters, objects
- dialogue/choices
- camera state

## 5. Renderer (пересмотр)

### 5.1 Единый пайплайн
Цель: SceneGraph -> RenderGraph -> CommandQueue -> GPU.
Текущее состояние: editor использует QGraphicsView, runtime — OpenGL snapshot.

### 5.2 Практическая схема
- Renderer backend: SDL2/OpenGL (как уже начато).
- Scene objects -> Renderables (Sprite/Text/FX).
- UI overlay (dialogue/choices) как отдельный слой.

### 5.3 Гарантия WYSIWYG
Если объект видно в editor, он точно так же виден в runtime.

## 6. Вопросы и ответы (критические мелочи)

Q: Что считается источником истины: Scene Graph или NMScript?
A: Авторинг хранится в проекте (ASG + Story Graph). NMScript — производное,
   но редактируемое. Синхронизация в обе стороны.

Q: Что происходит при редактировании кода во время play?
A: Редактирование разрешено, но изменения применяются после stop или
   через "hot reload" (опционально).

Q: Где живет диалог/текст?
A: Как часть Story Node + локальный override.

Q: Что делать, если фон отсутствует?
A: Рендерер показывает placeholder + error в Diagnostics.

Q: Что показывать при play без entry?
A: Play невозможен -> явная ошибка.

Q: Что если Scene Node не имеет дельт?
A: Используется базовая сцена без изменений.

Q: Можно ли запускать play из узла?
A: Да. Runtime создается, затем применяются дельты из узла,
   затем запускается скрипт с этого узла.

Q: Как избежать несоответствия Story Graph и NMScript?
A: Сохранять стабильные идентификаторы узлов и привязку к строкам кода.

Q: Как хранить "вход" в узел?
A: NodeRef = {sceneId, nodeId, scriptLocation}.

Q: Как управлять временем (анимация/таймлайн)?
A: Таймлайн хранит треки, а runtime во время play тикает их.
