#pragma once

#include "NovelMind/core/result.hpp"
#include "NovelMind/core/types.hpp"
#include <array>
#include <iosfwd>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

#ifdef NOVELMIND_HAS_OPENSSL
#include <openssl/evp.h>
#endif

namespace NovelMind::VFS {

enum class PackVerificationResult {
  Valid,
  InvalidMagic,
  InvalidVersion,
  CorruptedHeader,
  CorruptedResourceTable,
  CorruptedData,
  ChecksumMismatch,
  SignatureInvalid,
  DecryptionFailed
};

struct PackVerificationReport {
  PackVerificationResult result = PackVerificationResult::Valid;
  std::string message;
  u32 errorOffset = 0;
  std::string resourceId;
};

struct PackResourceMeta {
  u32 type = 0;
  u64 uncompressedSize = 0;
  u32 checksum = 0;
};

class PackIntegrityChecker {
public:
  PackIntegrityChecker() = default;

  // Public key is generated by the pack build pipeline and injected into the
  // runtime (embedded or loaded from a trusted path). The runtime is the trust
  // boundary; pack files are untrusted.
  Result<void> setPublicKeyPem(const std::string &pem);
  Result<void> setPublicKeyFromFile(const std::string &path);

  [[nodiscard]] Result<PackVerificationReport> verifyHeader(const u8 *data,
                                                            usize size);

  [[nodiscard]] Result<PackVerificationReport>
  verifyResourceTable(const u8 *data, usize size, u64 tableOffset,
                      u32 resourceCount);

  [[nodiscard]] Result<PackVerificationReport>
  verifyResource(const u8 *data, usize size, u64 offset, usize resourceSize,
                 u32 expectedChecksum);

  [[nodiscard]] Result<PackVerificationReport>
  verifyPackSignature(const u8 *data, usize size, const u8 *signature,
                      usize signatureSize);
  [[nodiscard]] Result<PackVerificationReport>
  verifyPackSignatureStream(std::istream &stream, usize size,
                            const u8 *signature, usize signatureSize);

  [[nodiscard]] static u32 calculateCrc32(const u8 *data, usize size);
  [[nodiscard]] static std::array<u8, 32> calculateSha256(const u8 *data,
                                                          usize size);

private:
#ifdef NOVELMIND_HAS_OPENSSL
  struct EVPKeyDeleter {
    void operator()(EVP_PKEY *key) const;
  };
  std::unique_ptr<EVP_PKEY, EVPKeyDeleter> m_publicKey;
#endif
};

class PackDecryptor {
public:
  PackDecryptor() = default;

  void setKey(const std::vector<u8> &key);
  void setKey(const u8 *key, usize keySize);

  [[nodiscard]] Result<std::vector<u8>> decrypt(const u8 *data, usize size,
                                                const u8 *iv, usize ivSize,
                                                const u8 *aad,
                                                usize aadSize);

  [[nodiscard]] static Result<std::vector<u8>>
  deriveKey(const std::string &password, const u8 *salt, usize saltSize);

  [[nodiscard]] static Result<std::vector<u8>>
  generateRandomIV(usize size = 16);

private:
  std::vector<u8> m_key;
};

class SecurePackReader {
public:
  SecurePackReader() = default;
  ~SecurePackReader() = default;

  void setDecryptor(std::unique_ptr<PackDecryptor> decryptor);
  void setIntegrityChecker(std::unique_ptr<PackIntegrityChecker> checker);
  Result<void> setPublicKeyPem(const std::string &pem);
  Result<void> setPublicKeyFromFile(const std::string &path);

  [[nodiscard]] Result<void> openPack(const std::string &path);
  void closePack();

  [[nodiscard]] Result<std::vector<u8>>
  readResource(const std::string &resourceId);

  [[nodiscard]] bool isOpen() const { return m_isOpen; }
  [[nodiscard]] PackVerificationResult lastVerificationResult() const {
    return m_lastResult;
  }
  [[nodiscard]] bool exists(const std::string &resourceId) const;
  [[nodiscard]] std::vector<std::string> listResources() const;
  [[nodiscard]] std::optional<PackResourceMeta>
  getResourceMeta(const std::string &resourceId) const;
  [[nodiscard]] u32 packFlags() const { return m_header.flags; }

private:
  struct PackHeader {
    u32 magic;
    u16 versionMajor;
    u16 versionMinor;
    u32 flags;
    u32 resourceCount;
    u64 resourceTableOffset;
    u64 stringTableOffset;
    u64 dataOffset;
    u64 totalSize;
    u8 contentHash[16];
  };

  struct PackResourceEntry {
    u32 idStringOffset;
    u32 type;
    u64 dataOffset;
    u64 compressedSize;
    u64 uncompressedSize;
    u32 flags;
    u32 checksum;
    u8 iv[8];
  };

  struct PackFooter {
    u32 magic;
    u32 tablesCrc32;
    u64 createdTimestamp;
    u32 buildNumber;
    u8 reserved[12];
  };

  std::unique_ptr<PackDecryptor> m_decryptor;
  std::unique_ptr<PackIntegrityChecker> m_integrityChecker;
  std::string m_packPath;
  PackHeader m_header{};
  PackFooter m_footer{};
  u64 m_fileSize = 0;
  std::unordered_map<std::string, PackResourceEntry> m_entries;
  std::vector<std::string> m_stringTable;
  bool m_isOpen = false;
  PackVerificationResult m_lastResult = PackVerificationResult::Valid;
};

} // namespace NovelMind::VFS
